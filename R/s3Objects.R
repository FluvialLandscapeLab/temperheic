#'Temperheic Aquifer, Boundary, and Units objects
#'
#'@description The \code{temperheic} package relies on three different S3
#'  objects: \code{thAquifer}, \code{thBoundary}, and \code{thUnits}.  The "th"
#'  prefix is short for "temperheic".  A \code{thAquifer} object contains
#'  user-specified and derived aquifer properties.  A \code{thBoundary} object
#'  contains user-specified and derived values that describe a time varying
#'  temperature boudary as a cosine function.  A \code{thUnits} object describes
#'  the units of measure used to specify \code{thAquifer} and \code{thBoundary}
#'  objects.
#'
#'  NOTE THAT THE USER IS RESPONSIBLE FOR ENSURING THAT THE UNITS OF ALL
#'  ARGUMENTS PASSED TO \code{TEMPERHEIC} PACKAGE FUNCTIONS ARE CONSISTENT. See
#'  Details (below) for more information on units.
#'
#'@details \code{thAquifer} objects include values for the arguments provided by
#'  the user (see 'Arguments', above), along with the following derived values:
#'
#'  \itemize{
#'
#'  \item{\code{darcyFlux}}{  Darcy Flux (L t-1) is flux rate of water through
#'  the aquifer along the hydrologic gradient. Calculated as:
#'  \code{hydCond*headGrad}.}
#'
#'  \item{\code{density_bulk}}{  Density of the bulk medium (M L-3) is the
#'  average density of water and sediment, weighted by porosity.  Calculated as:
#'  \code{density_sed*(1-porosity)+density_h2o*porosity}.}
#'
#'  \item{\code{spHeat_bulk}}{  Specific heat of the bulk medium (E M-1 T-1) is
#'  the average specific heat of water and sediments, weighted by porosity.
#'  Calculated as: \code{spHeat_sed*(1-porosity)+spHeat_h2o*porosity}.}
#'
#'  \item{\code{velocity_h2o}}{  Water velocity (L T-1) is the aerial averaged
#'  rate of water movement along the hydrologic gradient in the aquifer.
#'  Calculated as: \code{darcyFlux/porosity}.}
#'
#'  \item{\code{darcyFlux_heat}}{  Heat velocity (L T-1) is the aerially
#'  averaged rate of heat movement along the hydraulic gradient in the aquifer.
#'  Calculated as: \code{darcyFlux_h2o*(volHeatCap_h2o/volHeatCap_bulk)} Note
#'  that the temperheic package represents 1D movement of water and heat, so
#'  that heat gradients and hydrologic gradients are always aligned.}
#'
#'  \item{\code{volHeatCap_h2o, volHeatCap_sed}}{  The volumetric heat capacity
#'  of of water, and of sediment [E L-3 T-1] are calcuated from the
#'  corresponding values for specific heat and density:
#'  \code{spHeat_<x>*density_<x>}.}
#'
#'  \item{\code{volHeatCap_bulk} {  The volumentric heat capacity of the bulk
#'  medium [E L-3 T-1] is calcuated as the porosity-weighted average of
#'  volumetric heat capacity of water and sediment:
#'  volHeatCap_sed*(1-porosity)+volHeatCap_h2o*porosity}.}
#'
#'  }
#'
#'@param hydCond Hydraulic conductivity (L t-1) (either vertical or horizontal)
#'  of the aquifer.
#'@param dispersivity Dispersivity (L) of the aquifer, appropriate for the the
#'  scale of the flow path observed (see Gelher 20XX).
#'@param headGrad Average head gradient (L L-1) in the same dimension (vertical
#'  or horizonal) for the aquifer.
#'@param porosity Porosity (L3 L-3) of the aquifer; ratio of water volume to
#'  unit aquifer volume under saturated conditions.
#'@param thermCond_sed Thermal conductivity (E t-1 L-1 T-1) of the sediment.
#'@param thermCond_h2o Thermal conductivity (E t-1 L-1 T-1) of water.
#'@param spHeat_sed Specific heat (E M-1 T-1) of the sediment.
#'@param spHeat_h2o Specific heat (E M-1 T-1) of water.
#'@param density_sed Density (M L-3) of sediment.
#'@param density_h2o Density (M L-3) of water.
#'@param specificUnits A \code{thUnits} object generated by calling
#'  \code{thUnits()}. Specifies the units of length (L), mass (M), time (t),
#'  temperature (T), and energy (E) used in the numeric arguments.  A
#'  \code{thUnits} object is used only to label the values provided by the user,
#'  in hopes of helping the user avoid errors.  The \code{temperheic} package
#'  makes no conversions.  The user must ensure that all arguments passed to
#'  \code{thAquifer()} and \code{thBoundary()} have units consistent with
#'  \code{specificUnits}.
#'@return \code{thAquifer()} returns a S3 object of class \code{thAquifer} which
#'  includes all specified and derived parameters for the aquifer
#'@export
thAquifer = function (porosity, thermCond_sed, thermCond_h2o, spHeat_sed, spHeat_h2o, density_sed, density_h2o, specificUnits = thUnits()) {
  spHeat_bulk = spHeat_sed * (1 - porosity) + spHeat_h2o * porosity # E M-1 T-1
  density_bulk = density_sed * (1 - porosity) + density_h2o * porosity # E M-2 T-1

  volHeatCap_h2o = spHeat_h2o * density_h2o # E L-3 T-1
  volHeatCap_sed = spHeat_sed * density_sed # E L-3 T-1
  volHeatCap_bulk = volHeatCap_sed * (1 - porosity) + volHeatCap_h2o * porosity # E L-3 T-1

  thermCond_bulk = thermCond_sed * (1 - porosity) + thermCond_h2o * porosity

  newAquifer = .temperheic(
    thEnvir = environment(),
    thClass = "thAquifer",
    generalUnits =  c(
      rep("M L-3", 3),
      "L3 L-3",
      rep("E M-1 T-1", 3),
      rep("E t-1 L-1 T-1", 3),
      rep("E L-3 T-1", 3)
    ),
    specificUnits = specificUnits
  )
  return(newAquifer)
}

#' @rdname thAquifer
#' @details \code{thBoundary} objects include values for the arguments provided
#'   by the user (see 'Arguments', above), along with the following derived
#'   value:
#'
#'   \itemize{
#'
#'   \item{\code{frequency}}{  Frequency (t-1) of the temperature signal at the
#'   boundary.  Calculated as: \code{1/period}.}
#'
#'   }
#'
#' @return \code{thBoundary} returns an S3 object of class \code{thBoundary}, which
#'   includes the specified and derived parameters describing a temperature
#'   signal at the aquifer boundary.
#' @export
thBoundary = function(mean, amplitude, phase, period, specificUnits = thUnits()) {
  frequency = 1/period
  newBoundary = .temperheic(
    thEnvir = environment(),
    thClass = "thBoundary",
    generalUnits = c(
      "T",
      "t-1",
      "T",
      rep("t",2)
    ),
    specificUnits = specificUnits
  )
  return(newBoundary)
}

#' @rdname thAquifer
#' @details \code{thUnits} objects include unit labels for the parameter values
#'   stored in \code{thAquifer} and \code{thBoundary} objects.  Labels for units
#'   of length (L), mass (M), time (t), temperature (T), and Energy (E) are
#'   specified when creating a \code{thUnits} object.  The \code{thUnits} object
#'   can be stored in a variable and subsequently passed to \code{thAquifer()}
#'   and \code{thBoundary()}.  Note that the \code{thUnits} object is used ONLY
#'   to create lables for \code{thAquifer} and \code{thBoundary} values.  No
#'   attempt is made to convert to common units.  The user is responsible for
#'   ensuring that the units of all values in \code{thAquifer} and
#'   \code{thBoundary} objects agree with the unit labels displayed when the
#'   object is printed.
#' @return \code{thUnits()} return an S3 object of class \code{thUnits}, which
#'   includes specific units of length, mass, time, temperature, and energy. The
#'   values in a \code{thUnits} object are used to create unit labels for
#'   \code{thAquifer} and \code{thBoundary} parameter values.
#' @param L A chararcter string label for units of length.  Default is 'm' for
#'   meters.
#' @param M A chararcter string label for units of mass.  Default is 'kg' for
#'   kilograms.
#' @param t A chararcter string label for units of time.  Default is 's' for
#'   seconds.
#' @param T A chararcter string label for units of temperature.  Default is
#'   "degC" for degrees celsius.
#' @param E A chararcter string label for units of Energy. Default is "kJ" for
#'   kilojoules.
#' @export
thUnits = function(L = "m", M = "kg", t = "s", T = "degC", E = "kJ") {
  #get the list of argument names that can be passed to this function.
  unitNames = names(formals())
  #get the corresponding values, as a list
  unitList = sapply(unitNames, get, envir = environment(), simplify = F
  )

  newUnits = structure(
    unitList,
    class = c("thUnits"),
    longUnitName = c("Length", "Mass", "Time", "Temperature", "Energy")
  )
  return(newUnits)
}

#' @export
thHydro = function(hydCond, dispersivity, headGrad, aq, specificUnits) {
  if(!is.thUnits(specificUnits)) stop("Units must be specified as a 'thUnits' object; call 'thUnits()' to generate such an object.")
  if(!is.thAquifer(aq)) stop("The 'aquifer' argument must be a thAquifer object; call 'thAquifer()' to generate such an object.")
  if(!identical(specificUnits, attr(aq, "specificUnits"))) stop("The units of the aquifer are not the same as those specificed in 'specificUnits.'")
  darcyFlux = hydCond*headGrad # Darcy velocity L t-1
  velocity_h2o = (darcyFlux / aq$porosity); # Water velocity L t-1
  advectiveThermVel = darcyFlux * (aq$volHeatCap_h2o / aq$volHeatCap_bulk) # L t-1; areally averaged rate of heat movement (eqn 5, Luce et al 2013)

  diffusivity_cond = aq$thermCond_bulk / aq$volHeatCap_bulk
  diffusivity_disp = (dispersivity * advectiveThermVel)
  diffusivity_effective = diffusivity_disp + diffusivity_cond

  newHydro = .temperheic(
    thEnvir = environment(),
    thClass = "thHydro",
    generalUnits = c(
      rep("L t-1",2),
      rep("L2 t-1",3),
      "L",
      "L L-1",
      rep("L t-1",2)
    ),
    specificUnits = specificUnits,
    attrs = "aq",
    attrNames = "aquifer"
  )
  return(newHydro)

}

#' @export
thSignal = function(aq, hy, bd) {
## TO DO:  TEST TO BE SURE UNITS ARE ALL IDENTICAL!
  ##  if(!allIdentical(ALL THE UNITS))
  phaseVel_cond = sqrt(2 * hy$diffusivity_cond * 2 * pi * bd$frequency)
  phaseVel_disp = sqrt(2 * hy$diffusivity_disp * 2 * pi * bd$frequency)
  phaseVel = sqrt(2 * hy$diffusivity_effective * 2 * pi * bd$frequency)

  thermDecayDist_cond = sqrt(2 * hy$diffusivity_cond / (2 * pi * bd$frequency))
  thermDecayDist_disp = sqrt(2 * hy$diffusivity_disp / (2 * pi * bd$frequency))
  thermDecayDist = sqrt(2 * hy$diffusivity_effective / (2 * pi * bd$frequency))

  newSignal = .temperheic(
    thEnvir = environment(),
    thClass = "thSignal",
    generalUnits = c(
      rep("L t-1",3),
      rep("L" ,3)
    ),
    specificUnits = attr(aq, "specificUnits"),
    attrs = c("aq", "hy", "bd"),
    attrNames = c("aquifer", "hydro", "boundary")
  )
  return(newSignal)

}

.temperheic = function(thEnvir, thClass, generalUnits, specificUnits, attrs = NULL, attrNames = attrs) {
  attrs = c(attrs)
  if(!is.thUnits(specificUnits)) stop("Units must be specified as a 'thUnits' object; call 'thUnits()' to generate such an object.")
  elementNames = ls(envir = thEnvir)
  elementNames = elementNames[!(elementNames %in% attrs)]
  newTemperheic = structure(
    sapply(elementNames, function(x) get(x, envir = thEnvir), simplify = F),
    class = c(thClass, "temperheic"),
    units = .thSpecificUnits(generalUnits, specificUnits),
    derivedValues = elementNames[!elementNames %in% names(formals(thClass))]
  )
  if(!is.null(attrs)) {
    attributeList = sapply(attrs, function(x) get(x, envir = thEnvir), simplify = F)
    for (i in 1:length(attributeList)) {
      attr(newTemperheic, attrNames[i]) = attributeList[[i]]
    }
  }
  attr(newTemperheic, "specificUnits") = specificUnits
  return(newTemperheic)
}

#' @export
print.temperheic = function(x, ...) {
  # star = c("", "*")
  # starVector = star[as.integer(names(x) %in% attributes(x)[["derivedValues"]])+1]
  derivedNames = attributes(x)[["derivedValues"]]
  title = c("User-specified values:\n", "Derived values:\n")
  inDerived = c(FALSE, TRUE)
  for (i in 1:2) {
    printEm = (names(x) %in% derivedNames) == inDerived[i]
    if(any(printEm)){
      cat(title[i])
      cat(paste0("  ", names(x[printEm]), " = ", x[printEm], " (", attributes(x)[["units"]][printEm], ")\n"), sep="")
    }
  }
  cat("Additional attributes:", paste0(names(attributes(x)), collapse = ", "))
}

#' @export
print.thUnits = function(x, ...) {
  cat(paste0(names(x), " = '", x, "'", collapse = "; "))
}

#' @export
is.thUnits = function(x) {
  return(is(x, "thUnits"))
}

#' @export
is.thAquifer = function(x) {
  return(is(x, "thAquifer"))
}

#' @export
is.thBoundary = function(x) {
  return(is(x, "thBoundary"))
}
