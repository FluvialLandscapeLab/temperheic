#' @export
as.xts.thSeries = function(x, POSIXct.origin) {
  theOrder = as.POSIXct(x$time, origin = POSIXct.origin)
  x = x[-match("time", names(x))]
  x = xts(x, order.by = theOrder)
  return(x)
}

#' @export
as.zoo.thSeries = function(x, POSIXct.origin) {
  theOrder = as.POSIXct(x$time, origin = POSIXct.origin)
  x = x[-match("time", names(x))]
  x = zoo(x, order.by = theOrder)
  return(x)
}

#' @export
htPlot = function(myThSeries, POSIXct.origin = "2014-01-01 00:00:00") {
  myXTS = as.xts.thSeries(myThSeries, POSIXct.origin)
  plot(myXTS$x0, main = "", ylab = "Temperature (degC)", type = 'n', auto.grid = F, minor.ticks = F)
  lines(myXTS$x0, col = "grey70", lwd = 3, lty=2)
  for(col in names(myXTS)[2:length(names(myXTS))]) {
    lines(myXTS[,col], lwd = 3)
  }
  seriesAttr = attributes(myThSeries)
  sg = attr(myThSeries, "signal")
  hy = attr(sg, "hydro")
  k = hy$hydCond
  d = hy$dispersivity
  text(as.numeric(min(index(myXTS))), max(myXTS$x0), pos = 4, paste0("k = ", round(k,6), "  B = ", round(d, 6)))
}



# Replaces general units (e.g., "E t-1 L-3 T-1") with specific units specified
# by the user (e.g., "kJ s-1 m-3 degC-1")
.thSpecificUnits = function(generalUnits, specificUnits = thUnits()) {
  atomicUnits = unlist(lapply(generalUnits, strsplit, split = " "), recursive = F)

  #regular expression for an optional "-" and any number of digits at the end of
  #a string
  pattern = "[-]?[[:digit:]]+$"
  #strip off any match to pattern
  generalSymbols = lapply(atomicUnits, sub, pattern = pattern, replacement = "")
  #return any substring that matches to pattern
  generalExponents =
    lapply(
      atomicUnits,
      function(x) {
        locations = regexpr(pattern = pattern, x)
        locations[locations == -1] = 1000000L
        substring(x, locations)
      }
    )

  #return any generalSymbols that are not expected.  If any, throw error and
  #report to user
  unexpectedGenUnits = sapply(generalSymbols, function(x) {any(!(x %in% names(specificUnits)))})
  if(any(unexpectedGenUnits)) {
    cat("Unexpected general units found in: ", paste0("'", generalUnits[unexpectedGenUnits], "'", collapse = ", "), '\n  Expected units are: ', paste0(attributes(specificUnits)$longUnitName, "='", names(specificUnits), "'", collapse = ", "))
    stop("A general unit can be followed by positive or negative number (representing and exponent).\nThere can be no space between a unit and its exponent (e.g., 'M-3' not 'M -3').\nThere must be spaces between unit/exponent pairs (e.g. 'E L-3', not 'EL-3')")
  }

  #replace the generalSymbols with corresponding specific ones
  generalSymbols = lapply(generalSymbols, function(x) unlist(specificUnits)[x])
  #concatinate specific units with exponents and return vector specific units and exponents
  return(mapply(paste0, generalSymbols, generalExponents, collapse = " "))
}

#' Mean Squared Residuals and linear regression between two lagged time series
#'
#' Functions for regression two time series against one another (y ~ x), while
#' accounting for any lag time of the pattern in y realative to similar patterns
#' in x.
#'
#' When two time series of the same length are subjected to a lag, the number of
#' x,y pairs is reduced in proportion to the size of the lag because the series
#' are become more and more offset in time (analogous to the reduction of the
#' amount of overlap between two meter-sticks, which start out aligned, but are
#' then then slid in opposite directions).  The nmin ensures that the estimate
#' of mean squared residuals is based on at least nmin x,y pairs, once the time
#' lag in y is accounted for.
#'
#' \code{laggedMSR()} is desigend to be passed to optimize() in order to find the lag
#' with the minimum mean squared residuals between time series x and y.
#'
#' @return \code{laggedMSR} Returns the mean squared residuals of a linear model
#'   (y ~ x) given a time series x and y, assuming thattime series y lags time
#'   series x by lag time units.
#' @param lag Time that time series y lags time series x.
#' @param x,y Time series observations as vectors
#' @param t A vector of times of observations of values in x and y
#' @param nmin Minimum number of x.y pairs desired (see Details)
#' @export
laggedMSR = function(lag, thSeriesPair, nmin) {
  lData = laggedData(lag, thSeriesPair)
  if(nrow(lData) < nmin) {
    result = -1
  } else {
    fit = laggedModel(lData)
    a=coefficients(fit)
    result = mean((lData[,2] - (a[1] + abs(a[2]) * lData[,1]))^2)
  }
  return(result)
}

#' @rdname laggedMSR
#' @return \code{laggedModel} runs \code{\link{lm}()} on lData and returns
#'   the results.  Usually, lData is generated by calling \code{laggedData()}
#' @param lData A zoo object, typcally returned by calling \code{laggedData()}
#' @export
laggedModel = function(lData) {
  return(lm(lData[,2] ~ lData[,1]))
}

#'@rdname laggedMSR
#'@return \code{laggedData()} creates a \code{\link{zoo}} object with two
#'  columns (x and y).  Each row in the zoo object contains a pair of
#'  observations, after accounting for the lag -- the amount of time y lags x.
#'  \code{\link{na.spline}()} is used to calculate the y column in the zoo
#'  object if lag is not an even multiple of the times between observations.
#'@export
laggedData = function(lag, thSeriesPair) {
  # Create zoo objects
  thSeriesX = thSeriesPair[,1]
  thSeriesY = thSeriesPair[,2]
  zoo::index(thSeriesY) = zoo::index(thSeriesY) - lag
  # Merge series into one object
  storeNames = names(thSeriesPair)
  thSeriesPair <- merge(thSeriesX, thSeriesY)
  names(thSeriesPair) = storeNames
  # Interpolate calibration data (na.spline could also be used)
  thSeriesPair[,2] <- zoo::na.approx(object = thSeriesPair[,2], na.rm = F)
  # Only keep index values from sample data
  thSeriesPair <- thSeriesPair[!(is.na(thSeriesPair[,1]) | is.na(thSeriesPair[,2])) ,]
  return(thSeriesPair)
}

# converts passed values into 3d array
derivedArray = function(ampRatio, deltaPhaseRadians, eta, seriesNames) {
  derivedVals = array(
    data = c(ampRatio, deltaPhaseRadians, eta),
    dim = c(length(seriesNames), length(seriesNames), 3),
    dimnames = list(from = seriesNames, to = seriesNames, value = c("ampRatio", "deltaPhaseRadians", "eta"))
  )
  return(derivedVals)
}
